---
applyTo: "**"
---
# Project Coding Standards - Flask Invoice Management System

## Tech Stack
- **Backend**: Python 3.10+ with Flask
- **Database**: PostgreSQL (primary), MySQL/MariaDB (supported)
- **Frontend**: Jinja2 Templates, Vanilla JavaScript
- **Style**: Bootstrap 5, Custom CSS

## Naming Conventions (PEP 8)
- Use `PascalCase` for class names (e.g., `Invoice`, `CustomerService`)
- Use `snake_case` for functions, methods, and variables (e.g., `calculate_total`, `tax_rate`)
- Prefix private class members with underscore (e.g., `_internal_id`)
- Use `ALL_CAPS` for constants (e.g., `DEFAULT_TAX_RATE`, `MAX_ITEMS`)
- Database tables: lowercase with underscores (e.g., `invoice_items`, `customers`)
- Flask routes: kebab-case URLs (e.g., `/invoice/create`, `/api/customer-list`)

## Code Style
- **Line Length**: 160 characters (configured in black, flake8, isort)
- **Indentation**: 4 spaces (never tabs)
- **Imports**: Organized with isort (stdlib → third-party → local)
- **Formatting**: Automated with black
- **Strings**: Prefer f-strings for formatting, single quotes for simple strings

## Error Handling
- Use try/except blocks for database operations and external services
- Always log errors with `logger.error()` including context
- Flash user-friendly messages with appropriate categories ('error', 'warning', 'success')
- Use `except Exception` for Flask routes (acceptable for web apps)
- Implement proper rollback on database errors

## Flask Best Practices
- Use `@login_required` decorator for protected routes
- Validate form data with proper error messages
- Use `db.session.commit()` explicitly, handle rollbacks
- Implement CSRF protection for forms
- Use `flash()` for user feedback
- Keep route handlers focused, extract business logic to service functions

## Database
- Use SQLAlchemy ORM for queries
- Always use parameterized queries (ORM handles this)
- Implement proper foreign key constraints
- Use database transactions for multi-step operations
- Add indexes for frequently queried columns

## Security
- Never commit secrets (use .env file)
- Sanitize user input (Flask/Jinja2 auto-escapes)
- Use `werkzeug.security` for password hashing
- Implement rate limiting for sensitive endpoints
- Use HTTPS in production
- Enable TOTP 2FA for admin users

## Testing
- Write tests for critical business logic
- Test edge cases (null values, empty strings, etc.)
- Mock external dependencies (email, PDF generation)
- Use fixtures for test data

## Git Commits
- Use conventional commits: `feat:`, `fix:`, `chore:`, `docs:`, `style:`, `refactor:`
- Keep commits atomic and focused
- Write clear commit messages in German (project language)
- Pre-commit hooks will auto-format code

## Documentation
- Add docstrings to public functions/classes
- Keep README.md updated with setup instructions
- Document complex business logic with inline comments
- Update CHANGELOG.md for significant changes
